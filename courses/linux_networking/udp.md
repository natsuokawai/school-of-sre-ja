# UDP

UDPはトランスポート層のプロトコルです。DNSはアプリケーション層のプロトコルで、（ほとんどの場合）UDPの上で動作します。UDPの話に入る前に、アプリケーション層とトランスポート層とは何かを理解しておきましょう。DNSプロトコルは、DNSクライアント（digなど）とDNSサーバー（namedなど）によって使用されます。トランスポート層は、DNSリクエストがDNSサーバープロセスに届くようにし、同様にレスポンスがDNSクライアントプロセスに届くようにします。1つのシステム上で複数のプロセスを実行することができ、それらは任意の[ポート](https://ja.wikipedia.org/wiki/%E3%83%9D%E3%83%BC%E3%83%88_(%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF))で待ち受けることができます。DNSサーバーは通常、ポート番号53で待ち受けます。クライアントがDNSリクエストを行う際には、必要なアプリケーションのペイロードを埋めた後、**sendto**システムコールを介してペイロードをカーネルに渡します。カーネルはランダムなポート番号([>1024](https://www.cyberciti.biz/tips/linux-increase-outgoing-network-sockets-range.html))をソースポート番号として選び、53をデスティネーションポート番号として、パケットを下位層に送ります。サーバー側のカーネルはパケットを受信すると、ポート番号を確認し、DNSサーバープロセスのアプリケーションバッファにパケットをキューイングします。このようなカーネルの処理を多重化（複数のアプリケーションからのパケットを同じ下位層にまとめること）、多重分離（単一の下位層から複数のアプリケーションにパケットを分離すること）といいます。多重化と多重分離はトランスポート層で行われます。

UDPは最も単純なトランスポート層プロトコルの一つで、多重化と多重分離のみを行います。もうひとつの一般的なトランスポート層プロトコルであるTCPは、信頼性の高い通信、フロー制御、輻輳制御など、他の多くの機能を備えています。UDPは軽量で、少ないオーバーヘッドで通信を処理するように設計されています。そのため、UDPは多重化や多重分離以上のことはできません。UDP上で動作するアプリケーションがTCPの機能のどれかを必要とする場合は、アプリケーションにそれを実装しなければなりません

この[Python wikiの例](https://wiki.python.org/moin/UdpCommunication)では、UDPクライアントとサーバのサンプルを取り上げています。ここでは、ポート番号5005で待ち受けているサーバに「Hello World」というアプリケーションのペイロードを送信しています。サーバーはこのパケットを受信し、クライアントからの「Hello World」文字列を表示します。

## SREの役割における応用

1. 基盤となるネットワークが遅く、UDP層がネットワーク層にパケットをキューイングできない場合、アプリケーションからのsendtoシステムコールは、バッファの一部が解放されたことをカーネルが発見するまでハングアップします。これはシステムのスループットに影響します。[sysctl変数](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/tuning_and_optimizing_red_hat_enterprise_linux_for_oracle_9i_and_10g_databases/sect-oracle_9i_and_10g_tuning_guide-adjusting_network_settings-changing_network_kernel_settings)の*net.core.wmem_max*および*net.core.wmem_default*を使用して書き込みメモリバッファの値を増やすことで、ネットワークの速度低下からアプリケーションを守ることができます。
2. 同様に、受信側のプロセスがバッファからの消費に時間がかかる場合、カーネルはバッファがいっぱいになってキューに入れられないパケットをドロップしなければなりません。UDPは信頼性を保証しないので、アプリケーション層が追跡しない限り、ドロップされたパケットはデータ損失の原因となります。sysctl変数の*rmem_default*と*rmem_max*を増やすことで、高速な送信者から低速なアプリケーションを守ることができます。
